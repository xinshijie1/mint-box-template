/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
	ethers,
	EventFilter,
	Signer,
	BigNumber,
	BigNumberish,
	PopulatedTransaction,
	BaseContract,
	ContractTransaction,
	Overrides,
	CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface ERC1155SingleCollectionUpgradeableInterface
	extends ethers.utils.Interface {
	functions: {
		"addToken(address,string,uint256)": FunctionFragment;
		"balanceOf(address,uint256)": FunctionFragment;
		"balanceOfBatch(address[],uint256[])": FunctionFragment;
		"burn(address,uint256,uint256)": FunctionFragment;
		"burnBatch(address,uint256[],uint256[])": FunctionFragment;
		"close()": FunctionFragment;
		"exists(uint256)": FunctionFragment;
		"initialize(address,string,string,string,address,uint256,(address,uint256,uint64,uint64,string))": FunctionFragment;
		"isApprovedForAll(address,address)": FunctionFragment;
		"isClosed()": FunctionFragment;
		"isLimited()": FunctionFragment;
		"isNeverClosed()": FunctionFragment;
		"isOpen()": FunctionFragment;
		"mint(address,uint256,uint256,bytes)": FunctionFragment;
		"name()": FunctionFragment;
		"open()": FunctionFragment;
		"owner()": FunctionFragment;
		"param()": FunctionFragment;
		"payToken()": FunctionFragment;
		"price()": FunctionFragment;
		"renounceOwnership()": FunctionFragment;
		"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": FunctionFragment;
		"safeTransferFrom(address,address,uint256,uint256,bytes)": FunctionFragment;
		"setApprovalForAll(address,bool)": FunctionFragment;
		"setClose(uint64)": FunctionFragment;
		"setContractURI(string)": FunctionFragment;
		"setOpen(uint64)": FunctionFragment;
		"setParam((address,uint256,uint64,uint64,string))": FunctionFragment;
		"setPayToken(address)": FunctionFragment;
		"setPrice(uint256)": FunctionFragment;
		"supportsInterface(bytes4)": FunctionFragment;
		"symbol()": FunctionFragment;
		"timestamp()": FunctionFragment;
		"tokens(uint256)": FunctionFragment;
		"totalSupply(uint256)": FunctionFragment;
		"transferOwnership(address)": FunctionFragment;
		"updateSupply(uint256,uint256)": FunctionFragment;
		"uri(uint256)": FunctionFragment;
		"valueOf(uint256)": FunctionFragment;
		"withdraw(address,address,uint256)": FunctionFragment;
	};

	encodeFunctionData(
		functionFragment: "addToken",
		values: [string, string, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "balanceOf",
		values: [string, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "balanceOfBatch",
		values: [string[], BigNumberish[]]
	): string;
	encodeFunctionData(
		functionFragment: "burn",
		values: [string, BigNumberish, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "burnBatch",
		values: [string, BigNumberish[], BigNumberish[]]
	): string;
	encodeFunctionData(functionFragment: "close", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "exists",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "initialize",
		values: [
			string,
			string,
			string,
			string,
			string,
			BigNumberish,
			{
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			}
		]
	): string;
	encodeFunctionData(
		functionFragment: "isApprovedForAll",
		values: [string, string]
	): string;
	encodeFunctionData(functionFragment: "isClosed", values?: undefined): string;
	encodeFunctionData(functionFragment: "isLimited", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "isNeverClosed",
		values?: undefined
	): string;
	encodeFunctionData(functionFragment: "isOpen", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "mint",
		values: [string, BigNumberish, BigNumberish, BytesLike]
	): string;
	encodeFunctionData(functionFragment: "name", values?: undefined): string;
	encodeFunctionData(functionFragment: "open", values?: undefined): string;
	encodeFunctionData(functionFragment: "owner", values?: undefined): string;
	encodeFunctionData(functionFragment: "param", values?: undefined): string;
	encodeFunctionData(functionFragment: "payToken", values?: undefined): string;
	encodeFunctionData(functionFragment: "price", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "renounceOwnership",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "safeBatchTransferFrom",
		values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
	): string;
	encodeFunctionData(
		functionFragment: "safeTransferFrom",
		values: [string, string, BigNumberish, BigNumberish, BytesLike]
	): string;
	encodeFunctionData(
		functionFragment: "setApprovalForAll",
		values: [string, boolean]
	): string;
	encodeFunctionData(
		functionFragment: "setClose",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "setContractURI",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "setOpen",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "setParam",
		values: [
			{
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			}
		]
	): string;
	encodeFunctionData(functionFragment: "setPayToken", values: [string]): string;
	encodeFunctionData(
		functionFragment: "setPrice",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "supportsInterface",
		values: [BytesLike]
	): string;
	encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
	encodeFunctionData(functionFragment: "timestamp", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "tokens",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "totalSupply",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "transferOwnership",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "updateSupply",
		values: [BigNumberish, BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "uri", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "valueOf",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "withdraw",
		values: [string, string, BigNumberish]
	): string;

	decodeFunctionResult(functionFragment: "addToken", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "balanceOfBatch",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "burnBatch", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "close", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "exists", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "isApprovedForAll",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "isClosed", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "isLimited", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "isNeverClosed",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "isOpen", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "open", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "param", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "payToken", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "price", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "renounceOwnership",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "safeBatchTransferFrom",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "safeTransferFrom",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "setApprovalForAll",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "setClose", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "setContractURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "setOpen", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "setParam", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "setPayToken",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "setPrice", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "supportsInterface",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "timestamp", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "tokens", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "totalSupply",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "transferOwnership",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "updateSupply",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "valueOf", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

	events: {
		"AddToken(uint256,address,string,uint256)": EventFragment;
		"ApprovalForAll(address,address,bool)": EventFragment;
		"MintToken(address,uint256,uint256)": EventFragment;
		"OwnershipTransferred(address,address)": EventFragment;
		"Payment(address,address,address,uint256,uint256,uint256)": EventFragment;
		"SetClose(uint64)": EventFragment;
		"SetContractURI(string)": EventFragment;
		"SetOpen(uint64)": EventFragment;
		"SetParam(tuple)": EventFragment;
		"SetPayToken(address)": EventFragment;
		"SetPrice(uint256)": EventFragment;
		"TransferBatch(address,address,address,uint256[],uint256[])": EventFragment;
		"TransferSingle(address,address,address,uint256,uint256)": EventFragment;
		"URI(string,uint256)": EventFragment;
		"UpdateSupply(uint256,uint256)": EventFragment;
		"Withdrawal(address,address,uint256)": EventFragment;
	};

	getEvent(nameOrSignatureOrTopic: "AddToken"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "MintToken"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "Payment"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetClose"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetContractURI"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetOpen"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetParam"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetPayToken"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "SetPrice"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "TransferBatch"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "TransferSingle"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "URI"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "UpdateSupply"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "Withdrawal"): EventFragment;
}

export type AddTokenEvent = TypedEvent<
	[BigNumber, string, string, BigNumber] & {
		tokenId: BigNumber;
		creator: string;
		uri: string;
		supply: BigNumber;
	}
>;

export type ApprovalForAllEvent = TypedEvent<
	[string, string, boolean] & {
		account: string;
		operator: string;
		approved: boolean;
	}
>;

export type MintTokenEvent = TypedEvent<
	[string, BigNumber, BigNumber] & {
		to: string;
		tokenId: BigNumber;
		amount: BigNumber;
	}
>;

export type OwnershipTransferredEvent = TypedEvent<
	[string, string] & { previousOwner: string; newOwner: string }
>;

export type PaymentEvent = TypedEvent<
	[string, string, string, BigNumber, BigNumber, BigNumber] & {
		payToken: string;
		from: string;
		to: string;
		tokenId: BigNumber;
		amount: BigNumber;
		value: BigNumber;
	}
>;

export type SetCloseEvent = TypedEvent<[BigNumber] & { time: BigNumber }>;

export type SetContractURIEvent = TypedEvent<[string] & { uri: string }>;

export type SetOpenEvent = TypedEvent<[BigNumber] & { time: BigNumber }>;

export type SetParamEvent = TypedEvent<
	[
		[string, BigNumber, BigNumber, BigNumber, string] & {
			payToken: string;
			price: BigNumber;
			open: BigNumber;
			close: BigNumber;
			uri: string;
		}
	] & {
		param: [string, BigNumber, BigNumber, BigNumber, string] & {
			payToken: string;
			price: BigNumber;
			open: BigNumber;
			close: BigNumber;
			uri: string;
		};
	}
>;

export type SetPayTokenEvent = TypedEvent<[string] & { payToken: string }>;

export type SetPriceEvent = TypedEvent<[BigNumber] & { price: BigNumber }>;

export type TransferBatchEvent = TypedEvent<
	[string, string, string, BigNumber[], BigNumber[]] & {
		operator: string;
		from: string;
		to: string;
		ids: BigNumber[];
		values: BigNumber[];
	}
>;

export type TransferSingleEvent = TypedEvent<
	[string, string, string, BigNumber, BigNumber] & {
		operator: string;
		from: string;
		to: string;
		id: BigNumber;
		value: BigNumber;
	}
>;

export type URIEvent = TypedEvent<
	[string, BigNumber] & { value: string; id: BigNumber }
>;

export type UpdateSupplyEvent = TypedEvent<
	[BigNumber, BigNumber] & { tokenId: BigNumber; supply: BigNumber }
>;

export type WithdrawalEvent = TypedEvent<
	[string, string, BigNumber] & {
		payToken: string;
		to: string;
		amount: BigNumber;
	}
>;

export class ERC1155SingleCollectionUpgradeable extends BaseContract {
	connect(signerOrProvider: Signer | Provider | string): this;
	attach(addressOrName: string): this;
	deployed(): Promise<this>;

	listeners<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
	): Array<TypedListener<EventArgsArray, EventArgsObject>>;
	off<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	on<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	once<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
	): this;

	listeners(eventName?: string): Array<Listener>;
	off(eventName: string, listener: Listener): this;
	on(eventName: string, listener: Listener): this;
	once(eventName: string, listener: Listener): this;
	removeListener(eventName: string, listener: Listener): this;
	removeAllListeners(eventName?: string): this;

	queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
		event: TypedEventFilter<EventArgsArray, EventArgsObject>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined
	): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

	interface: ERC1155SingleCollectionUpgradeableInterface;

	functions: {
		addToken(
			creator: string,
			uri_: string,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		balanceOf(
			account: string,
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		balanceOfBatch(
			accounts: string[],
			ids: BigNumberish[],
			overrides?: CallOverrides
		): Promise<[BigNumber[]]>;

		burn(
			account: string,
			id: BigNumberish,
			value: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		burnBatch(
			account: string,
			ids: BigNumberish[],
			values: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		close(overrides?: CallOverrides): Promise<[BigNumber]>;

		exists(id: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;

		initialize(
			newOwner: string,
			name: string,
			symbol: string,
			_uri: string,
			creator: string,
			supply: BigNumberish,
			param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		isApprovedForAll(
			account: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<[boolean]>;

		isClosed(overrides?: CallOverrides): Promise<[boolean]>;

		isLimited(overrides?: CallOverrides): Promise<[boolean]>;

		isNeverClosed(overrides?: CallOverrides): Promise<[boolean]>;

		isOpen(overrides?: CallOverrides): Promise<[boolean]>;

		mint(
			to: string,
			tokenId: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		name(overrides?: CallOverrides): Promise<[string]>;

		open(overrides?: CallOverrides): Promise<[BigNumber]>;

		owner(overrides?: CallOverrides): Promise<[string]>;

		param(
			overrides?: CallOverrides
		): Promise<
			[string, BigNumber, BigNumber, BigNumber, string] & {
				payToken: string;
				price: BigNumber;
				open: BigNumber;
				close: BigNumber;
				uri: string;
			}
		>;

		payToken(overrides?: CallOverrides): Promise<[string]>;

		price(overrides?: CallOverrides): Promise<[BigNumber]>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		safeBatchTransferFrom(
			from: string,
			to: string,
			ids: BigNumberish[],
			amounts: BigNumberish[],
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		safeTransferFrom(
			from: string,
			to: string,
			id: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setClose(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setContractURI(
			contractURI_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setOpen(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setParam(
			_param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setPayToken(
			payToken_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setPrice(
			price_: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<[boolean]>;

		symbol(overrides?: CallOverrides): Promise<[string]>;

		timestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

		tokens(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[BigNumber, number, string, string, BigNumber] & {
				id: BigNumber;
				status: number;
				creator: string;
				uri: string;
				supply: BigNumber;
			}
		>;

		totalSupply(
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		updateSupply(
			tokenId: BigNumberish,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		uri(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

		valueOf(
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		withdraw(
			payToken: string,
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;
	};

	addToken(
		creator: string,
		uri_: string,
		supply: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	balanceOf(
		account: string,
		id: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	balanceOfBatch(
		accounts: string[],
		ids: BigNumberish[],
		overrides?: CallOverrides
	): Promise<BigNumber[]>;

	burn(
		account: string,
		id: BigNumberish,
		value: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	burnBatch(
		account: string,
		ids: BigNumberish[],
		values: BigNumberish[],
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	close(overrides?: CallOverrides): Promise<BigNumber>;

	exists(id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

	initialize(
		newOwner: string,
		name: string,
		symbol: string,
		_uri: string,
		creator: string,
		supply: BigNumberish,
		param: {
			payToken: string;
			price: BigNumberish;
			open: BigNumberish;
			close: BigNumberish;
			uri: string;
		},
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	isApprovedForAll(
		account: string,
		operator: string,
		overrides?: CallOverrides
	): Promise<boolean>;

	isClosed(overrides?: CallOverrides): Promise<boolean>;

	isLimited(overrides?: CallOverrides): Promise<boolean>;

	isNeverClosed(overrides?: CallOverrides): Promise<boolean>;

	isOpen(overrides?: CallOverrides): Promise<boolean>;

	mint(
		to: string,
		tokenId: BigNumberish,
		amount: BigNumberish,
		data: BytesLike,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	name(overrides?: CallOverrides): Promise<string>;

	open(overrides?: CallOverrides): Promise<BigNumber>;

	owner(overrides?: CallOverrides): Promise<string>;

	param(
		overrides?: CallOverrides
	): Promise<
		[string, BigNumber, BigNumber, BigNumber, string] & {
			payToken: string;
			price: BigNumber;
			open: BigNumber;
			close: BigNumber;
			uri: string;
		}
	>;

	payToken(overrides?: CallOverrides): Promise<string>;

	price(overrides?: CallOverrides): Promise<BigNumber>;

	renounceOwnership(
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	safeBatchTransferFrom(
		from: string,
		to: string,
		ids: BigNumberish[],
		amounts: BigNumberish[],
		data: BytesLike,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	safeTransferFrom(
		from: string,
		to: string,
		id: BigNumberish,
		amount: BigNumberish,
		data: BytesLike,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setApprovalForAll(
		operator: string,
		approved: boolean,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setClose(
		time: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setContractURI(
		contractURI_: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setOpen(
		time: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setParam(
		_param: {
			payToken: string;
			price: BigNumberish;
			open: BigNumberish;
			close: BigNumberish;
			uri: string;
		},
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setPayToken(
		payToken_: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setPrice(
		price_: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	supportsInterface(
		interfaceId: BytesLike,
		overrides?: CallOverrides
	): Promise<boolean>;

	symbol(overrides?: CallOverrides): Promise<string>;

	timestamp(overrides?: CallOverrides): Promise<BigNumber>;

	tokens(
		arg0: BigNumberish,
		overrides?: CallOverrides
	): Promise<
		[BigNumber, number, string, string, BigNumber] & {
			id: BigNumber;
			status: number;
			creator: string;
			uri: string;
			supply: BigNumber;
		}
	>;

	totalSupply(id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	transferOwnership(
		newOwner: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	updateSupply(
		tokenId: BigNumberish,
		supply: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	uri(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	valueOf(amount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	withdraw(
		payToken: string,
		to: string,
		amount: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	callStatic: {
		addToken(
			creator: string,
			uri_: string,
			supply: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		balanceOf(
			account: string,
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		balanceOfBatch(
			accounts: string[],
			ids: BigNumberish[],
			overrides?: CallOverrides
		): Promise<BigNumber[]>;

		burn(
			account: string,
			id: BigNumberish,
			value: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		burnBatch(
			account: string,
			ids: BigNumberish[],
			values: BigNumberish[],
			overrides?: CallOverrides
		): Promise<void>;

		close(overrides?: CallOverrides): Promise<BigNumber>;

		exists(id: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

		initialize(
			newOwner: string,
			name: string,
			symbol: string,
			_uri: string,
			creator: string,
			supply: BigNumberish,
			param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: CallOverrides
		): Promise<void>;

		isApprovedForAll(
			account: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<boolean>;

		isClosed(overrides?: CallOverrides): Promise<boolean>;

		isLimited(overrides?: CallOverrides): Promise<boolean>;

		isNeverClosed(overrides?: CallOverrides): Promise<boolean>;

		isOpen(overrides?: CallOverrides): Promise<boolean>;

		mint(
			to: string,
			tokenId: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		name(overrides?: CallOverrides): Promise<string>;

		open(overrides?: CallOverrides): Promise<BigNumber>;

		owner(overrides?: CallOverrides): Promise<string>;

		param(
			overrides?: CallOverrides
		): Promise<
			[string, BigNumber, BigNumber, BigNumber, string] & {
				payToken: string;
				price: BigNumber;
				open: BigNumber;
				close: BigNumber;
				uri: string;
			}
		>;

		payToken(overrides?: CallOverrides): Promise<string>;

		price(overrides?: CallOverrides): Promise<BigNumber>;

		renounceOwnership(overrides?: CallOverrides): Promise<void>;

		safeBatchTransferFrom(
			from: string,
			to: string,
			ids: BigNumberish[],
			amounts: BigNumberish[],
			data: BytesLike,
			overrides?: CallOverrides
		): Promise<void>;

		safeTransferFrom(
			from: string,
			to: string,
			id: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: CallOverrides
		): Promise<void>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: CallOverrides
		): Promise<void>;

		setClose(time: BigNumberish, overrides?: CallOverrides): Promise<void>;

		setContractURI(
			contractURI_: string,
			overrides?: CallOverrides
		): Promise<void>;

		setOpen(time: BigNumberish, overrides?: CallOverrides): Promise<void>;

		setParam(
			_param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: CallOverrides
		): Promise<void>;

		setPayToken(payToken_: string, overrides?: CallOverrides): Promise<void>;

		setPrice(price_: BigNumberish, overrides?: CallOverrides): Promise<void>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<boolean>;

		symbol(overrides?: CallOverrides): Promise<string>;

		timestamp(overrides?: CallOverrides): Promise<BigNumber>;

		tokens(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[BigNumber, number, string, string, BigNumber] & {
				id: BigNumber;
				status: number;
				creator: string;
				uri: string;
				supply: BigNumber;
			}
		>;

		totalSupply(
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		transferOwnership(
			newOwner: string,
			overrides?: CallOverrides
		): Promise<void>;

		updateSupply(
			tokenId: BigNumberish,
			supply: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		uri(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		valueOf(
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		withdraw(
			payToken: string,
			to: string,
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;
	};

	filters: {
		"AddToken(uint256,address,string,uint256)"(
			tokenId?: null,
			creator?: null,
			uri?: null,
			supply?: null
		): TypedEventFilter<
			[BigNumber, string, string, BigNumber],
			{ tokenId: BigNumber; creator: string; uri: string; supply: BigNumber }
		>;

		AddToken(
			tokenId?: null,
			creator?: null,
			uri?: null,
			supply?: null
		): TypedEventFilter<
			[BigNumber, string, string, BigNumber],
			{ tokenId: BigNumber; creator: string; uri: string; supply: BigNumber }
		>;

		"ApprovalForAll(address,address,bool)"(
			account?: string | null,
			operator?: string | null,
			approved?: null
		): TypedEventFilter<
			[string, string, boolean],
			{ account: string; operator: string; approved: boolean }
		>;

		ApprovalForAll(
			account?: string | null,
			operator?: string | null,
			approved?: null
		): TypedEventFilter<
			[string, string, boolean],
			{ account: string; operator: string; approved: boolean }
		>;

		"MintToken(address,uint256,uint256)"(
			to?: string | null,
			tokenId?: null,
			amount?: null
		): TypedEventFilter<
			[string, BigNumber, BigNumber],
			{ to: string; tokenId: BigNumber; amount: BigNumber }
		>;

		MintToken(
			to?: string | null,
			tokenId?: null,
			amount?: null
		): TypedEventFilter<
			[string, BigNumber, BigNumber],
			{ to: string; tokenId: BigNumber; amount: BigNumber }
		>;

		"OwnershipTransferred(address,address)"(
			previousOwner?: string | null,
			newOwner?: string | null
		): TypedEventFilter<
			[string, string],
			{ previousOwner: string; newOwner: string }
		>;

		OwnershipTransferred(
			previousOwner?: string | null,
			newOwner?: string | null
		): TypedEventFilter<
			[string, string],
			{ previousOwner: string; newOwner: string }
		>;

		"Payment(address,address,address,uint256,uint256,uint256)"(
			payToken?: string | null,
			from?: string | null,
			to?: string | null,
			tokenId?: null,
			amount?: null,
			value?: null
		): TypedEventFilter<
			[string, string, string, BigNumber, BigNumber, BigNumber],
			{
				payToken: string;
				from: string;
				to: string;
				tokenId: BigNumber;
				amount: BigNumber;
				value: BigNumber;
			}
		>;

		Payment(
			payToken?: string | null,
			from?: string | null,
			to?: string | null,
			tokenId?: null,
			amount?: null,
			value?: null
		): TypedEventFilter<
			[string, string, string, BigNumber, BigNumber, BigNumber],
			{
				payToken: string;
				from: string;
				to: string;
				tokenId: BigNumber;
				amount: BigNumber;
				value: BigNumber;
			}
		>;

		"SetClose(uint64)"(
			time?: null
		): TypedEventFilter<[BigNumber], { time: BigNumber }>;

		SetClose(time?: null): TypedEventFilter<[BigNumber], { time: BigNumber }>;

		"SetContractURI(string)"(
			uri?: null
		): TypedEventFilter<[string], { uri: string }>;

		SetContractURI(uri?: null): TypedEventFilter<[string], { uri: string }>;

		"SetOpen(uint64)"(
			time?: null
		): TypedEventFilter<[BigNumber], { time: BigNumber }>;

		SetOpen(time?: null): TypedEventFilter<[BigNumber], { time: BigNumber }>;

		"SetParam(tuple)"(
			param?: null
		): TypedEventFilter<
			[
				[string, BigNumber, BigNumber, BigNumber, string] & {
					payToken: string;
					price: BigNumber;
					open: BigNumber;
					close: BigNumber;
					uri: string;
				}
			],
			{
				param: [string, BigNumber, BigNumber, BigNumber, string] & {
					payToken: string;
					price: BigNumber;
					open: BigNumber;
					close: BigNumber;
					uri: string;
				};
			}
		>;

		SetParam(
			param?: null
		): TypedEventFilter<
			[
				[string, BigNumber, BigNumber, BigNumber, string] & {
					payToken: string;
					price: BigNumber;
					open: BigNumber;
					close: BigNumber;
					uri: string;
				}
			],
			{
				param: [string, BigNumber, BigNumber, BigNumber, string] & {
					payToken: string;
					price: BigNumber;
					open: BigNumber;
					close: BigNumber;
					uri: string;
				};
			}
		>;

		"SetPayToken(address)"(
			payToken?: null
		): TypedEventFilter<[string], { payToken: string }>;

		SetPayToken(
			payToken?: null
		): TypedEventFilter<[string], { payToken: string }>;

		"SetPrice(uint256)"(
			price?: null
		): TypedEventFilter<[BigNumber], { price: BigNumber }>;

		SetPrice(price?: null): TypedEventFilter<[BigNumber], { price: BigNumber }>;

		"TransferBatch(address,address,address,uint256[],uint256[])"(
			operator?: string | null,
			from?: string | null,
			to?: string | null,
			ids?: null,
			values?: null
		): TypedEventFilter<
			[string, string, string, BigNumber[], BigNumber[]],
			{
				operator: string;
				from: string;
				to: string;
				ids: BigNumber[];
				values: BigNumber[];
			}
		>;

		TransferBatch(
			operator?: string | null,
			from?: string | null,
			to?: string | null,
			ids?: null,
			values?: null
		): TypedEventFilter<
			[string, string, string, BigNumber[], BigNumber[]],
			{
				operator: string;
				from: string;
				to: string;
				ids: BigNumber[];
				values: BigNumber[];
			}
		>;

		"TransferSingle(address,address,address,uint256,uint256)"(
			operator?: string | null,
			from?: string | null,
			to?: string | null,
			id?: null,
			value?: null
		): TypedEventFilter<
			[string, string, string, BigNumber, BigNumber],
			{
				operator: string;
				from: string;
				to: string;
				id: BigNumber;
				value: BigNumber;
			}
		>;

		TransferSingle(
			operator?: string | null,
			from?: string | null,
			to?: string | null,
			id?: null,
			value?: null
		): TypedEventFilter<
			[string, string, string, BigNumber, BigNumber],
			{
				operator: string;
				from: string;
				to: string;
				id: BigNumber;
				value: BigNumber;
			}
		>;

		"URI(string,uint256)"(
			value?: null,
			id?: BigNumberish | null
		): TypedEventFilter<[string, BigNumber], { value: string; id: BigNumber }>;

		URI(
			value?: null,
			id?: BigNumberish | null
		): TypedEventFilter<[string, BigNumber], { value: string; id: BigNumber }>;

		"UpdateSupply(uint256,uint256)"(
			tokenId?: null,
			supply?: null
		): TypedEventFilter<
			[BigNumber, BigNumber],
			{ tokenId: BigNumber; supply: BigNumber }
		>;

		UpdateSupply(
			tokenId?: null,
			supply?: null
		): TypedEventFilter<
			[BigNumber, BigNumber],
			{ tokenId: BigNumber; supply: BigNumber }
		>;

		"Withdrawal(address,address,uint256)"(
			payToken?: string | null,
			to?: string | null,
			amount?: null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ payToken: string; to: string; amount: BigNumber }
		>;

		Withdrawal(
			payToken?: string | null,
			to?: string | null,
			amount?: null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ payToken: string; to: string; amount: BigNumber }
		>;
	};

	estimateGas: {
		addToken(
			creator: string,
			uri_: string,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		balanceOf(
			account: string,
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		balanceOfBatch(
			accounts: string[],
			ids: BigNumberish[],
			overrides?: CallOverrides
		): Promise<BigNumber>;

		burn(
			account: string,
			id: BigNumberish,
			value: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		burnBatch(
			account: string,
			ids: BigNumberish[],
			values: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		close(overrides?: CallOverrides): Promise<BigNumber>;

		exists(id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		initialize(
			newOwner: string,
			name: string,
			symbol: string,
			_uri: string,
			creator: string,
			supply: BigNumberish,
			param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		isApprovedForAll(
			account: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		isClosed(overrides?: CallOverrides): Promise<BigNumber>;

		isLimited(overrides?: CallOverrides): Promise<BigNumber>;

		isNeverClosed(overrides?: CallOverrides): Promise<BigNumber>;

		isOpen(overrides?: CallOverrides): Promise<BigNumber>;

		mint(
			to: string,
			tokenId: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		name(overrides?: CallOverrides): Promise<BigNumber>;

		open(overrides?: CallOverrides): Promise<BigNumber>;

		owner(overrides?: CallOverrides): Promise<BigNumber>;

		param(overrides?: CallOverrides): Promise<BigNumber>;

		payToken(overrides?: CallOverrides): Promise<BigNumber>;

		price(overrides?: CallOverrides): Promise<BigNumber>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		safeBatchTransferFrom(
			from: string,
			to: string,
			ids: BigNumberish[],
			amounts: BigNumberish[],
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		safeTransferFrom(
			from: string,
			to: string,
			id: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setClose(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setContractURI(
			contractURI_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setOpen(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setParam(
			_param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setPayToken(
			payToken_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setPrice(
			price_: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		symbol(overrides?: CallOverrides): Promise<BigNumber>;

		timestamp(overrides?: CallOverrides): Promise<BigNumber>;

		tokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		totalSupply(
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		updateSupply(
			tokenId: BigNumberish,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		uri(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		valueOf(
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		withdraw(
			payToken: string,
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;
	};

	populateTransaction: {
		addToken(
			creator: string,
			uri_: string,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		balanceOf(
			account: string,
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		balanceOfBatch(
			accounts: string[],
			ids: BigNumberish[],
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		burn(
			account: string,
			id: BigNumberish,
			value: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		burnBatch(
			account: string,
			ids: BigNumberish[],
			values: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		close(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		exists(
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		initialize(
			newOwner: string,
			name: string,
			symbol: string,
			_uri: string,
			creator: string,
			supply: BigNumberish,
			param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		isApprovedForAll(
			account: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		isClosed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		isLimited(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		isNeverClosed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		isOpen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		mint(
			to: string,
			tokenId: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		open(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		param(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		payToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		price(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		safeBatchTransferFrom(
			from: string,
			to: string,
			ids: BigNumberish[],
			amounts: BigNumberish[],
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		safeTransferFrom(
			from: string,
			to: string,
			id: BigNumberish,
			amount: BigNumberish,
			data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setClose(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setContractURI(
			contractURI_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setOpen(
			time: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setParam(
			_param: {
				payToken: string;
				price: BigNumberish;
				open: BigNumberish;
				close: BigNumberish;
				uri: string;
			},
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setPayToken(
			payToken_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setPrice(
			price_: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		timestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		tokens(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		totalSupply(
			id: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		updateSupply(
			tokenId: BigNumberish,
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		uri(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		valueOf(
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		withdraw(
			payToken: string,
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;
	};
}
